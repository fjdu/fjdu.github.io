---
layout: post
title:  "通往哥德尔机的实现：关于自省系统的一课"
date:   2016-04-21 Thu 21:52:40
categories: artificial intelligence
---

作者：Bas R. Steunebrink and Jürgen Schmidhuber

来自：Pei Wang (Ed.) & Ben Goertzel (Ed.), Theoretical Foundations of Artificial General Intelligence, 第十章

<hr><p></p>

<h2>摘要</h2>
<p>
近期，人们对自省系统 (self-reflective system) 的兴趣在人工广义智能 (Artificial General Intelligence; AGI) 的语境下复苏了。一个 AGI 系统应该有足够的智能来对其自身的代码进行推理，并且在它认为合适的地方修改代码，从而改进最初由人类程序员写的代码。一个相关的例子是哥德尔机 (Gödel Machine)，它利用一个证明搜索器 (proof searcher)---平行于它通常的解题任务---来寻找对自身的重写，并且它自己可以证明这种重写是有利的。显然，要在 AGI 系统中实现这种层次的自省会有许多技术挑战，但这些挑战中有许多并没有被广泛了解或领会。本文中我们回到自省的理论基础，并检视真的要实现一个自省 AGI 系统 (以及哥德尔机) 时面临的问题 (通常很微妙)。
</p>

<h2>引言</h2>
<p>
一个人工广义智能 (AGI) 系统很可能会需要自省的能力；也就是说，在系统运行的过程中检视和推断自身的代码并对其进行综合修改。这是因为人类程序员不像有能力写出完全预先决定好的、不需要调节的程序来满足广义智能的要求。当然，自我修改可以有多种形式，从简单地通过机器学习技术调节几个参数，到对自身正在运行的代码有完全的读写权限的系统。本文中我们考虑迈向第二种极端---方法是构建一个编程语言以及一个允许对内部构造以安全和容易理解的方式进行完全省察和操纵的解释器---在技术上意味着什么。
</p>

<p>
能够省察和操纵自身代码不新鲜；事实上，在早期计算机内存很有限且昂贵的时候这是标准做法。但是，近些时间，不再鼓励使用自我修改的程序了，因为人类程序员很难掌控自我修改的所有后果 (特别是在大的时间跨度下)，使得这么做倾向于引入错误。结果就是，很多现代 (高级) 语言严格限制对内部构造 (比如调用栈) 的存取，或者干脆禁止。但是有两个原因让我们不应该永远禁止自我修改的程序。第一，仍然有可能发明一种允许写出安全且容易理解的自我修改程序的语言。第二，如今自动推理系统越来越成熟，考察让机器——而不是人类程序员——基于对其自身代码的自动推理去做所有自我修改，是有价值的。
</p>

<p>
做为上面第二个动机的实体化的一个例子，我们考虑哥德尔机，这样我们对自省的技术讨论会有的放矢一些。完全的自指哥德尔机是一个在某种意义上理论最优的通用人工智能。它可以与某些一开始未知、部分可观测的环境发生相互作用，来解决任何用户定义的计算任务，方法是让累积的未来效用的期望最大化。初始的算法不是硬植入的；它可以完全重写自身而没有除了可计算性之外任何实质上的限制，前提是初始算法要包含一个证明搜索器，这个搜索器能先证明重写是有用的，依据是考虑了有限计算资源的形式化效用函数。可以证明这种途径的自我修改对于初始效用函数 (比如强化学习的奖励函数) 来说是全局最优的，与此对比的是哥德尔关于可证明性的周知的基本限制。
</p>

<p>
下一节我们给出哥德尔机概念的描述，这提供了之后讨论自省系统的语境。上面已经指出，哥德尔机的实现要求系统能够对当前正在运行的程序作出任意修改。但这是什么意思？什么是一个修改，修改有多大的任意性，以及一个运行的程序长什么样？我们会看到这些都不是平凡问题，涉及到一些微妙而重要的问题。本文提供这些问题的综述以及克服办法。
</p>

<h2>哥德尔机的概念</h2>
<p>
可以把哥德尔机堪称由两部分组成的程序。第一部分我们称为求解器，可以是任何解决问题的程序。为了讲述的清晰，我们假定求解器是个与外部环境交互的强化学习 (RL) 程序。这让我们方便决定效用 (使用 RL 的奖励函数)，这在后面是个重要话题。但一般来说，对求解器没有限制。第二部分我们称为搜索器，是一个以可证明的最优方式改进整个哥德尔机的程序。搜索器是本节的主要话题。
</p>

<p>
哥德尔机的搜索器有一个计算这机器累积未来效用的期望值的函数。这个效用函数被用来构造目标定理；也就是说，哥德尔机会进行自我修改，仅当可证明这么做有用时。下面会看到，目标定理准确指定了何时重写是有用的。
</p>

<p>
基本来说，决定累积未来效用期望值的函数 (记为 \(u\)) 是所有未来时间点的奖励之和。这里时间点不是指时钟滴答，而是对基本指令的执行。事实上，每个指令要花时间来执行，所以如果我们能找到办法来明确表示未来将要执行的指令，我们自动有了开向未来时间的窗口。对于这种表示，一个明显的选择是延续 (continuation)，一个在基于 \(\lambda\)-运算的程序语言里被研究得很好的概念。直观地讲，一个延续可以被看成调用栈的反面；不是给出“我们来自哪里”，一个延续显式给出的是“下面将发生什么”。注意到除了最简单的情况之外，一个延续只会被部分展开。比如，假设当前的延续是 <code> { A(); if B() then C() else D() } </code>; 这个延续指出下一件要做的事情是展开 <code>A</code> 并执行其内容，然后执行条件语句，这意味着 <code>B</code> 会先被展开，然后根据其结果，<code>C</code> 或 <code>D</code> 之一被展开。在 <code>B</code> 执行之前是不清楚 <code>C</code> 或 <code>D</code> 要不要执行的；所以在知道 <code>B</code> 的结果之前展开它们没有意义。
</p>

<p>
下面我们用一致的下标来表示一个元素在何处被编码。\(u\) 是二元函数，\(u_{\bar{s}}(s, c)\)，代表的是在 \(s\) 状态下运行延续 \(c\) 的累计未来效用期望。这里 \(\bar{s}\) 是评估态 (evaluating state; \(u\) 编码的地方)，而 \(s\) 是被评估的态 (evaluated state)。考虑 \(u\) 的具体定义就清楚为什么作出这种区分了
\begin{equation}
\begin{split}
    u_{\bar{s}}(s,c) &= \mathbb{E}_{\mu_s,M_s}\left[u'\right],\ \text{其中}
    \\
    u'(env) &= r_{\bar{s}}(s, env) + \mathbb{E}_{\kappa_c,K_c}\left[u_{\bar{s}} | env\right]
\end{split}
    \label{eq_usbar}
\end{equation}
如下标标出的，外部环境的表示 \(M\) 在 \(s\) 内编码，因为哥德尔机的所有知识必须被 \(s\) 编码。为了清楚，让 \(M\) 是一个位串组成的集合，每个组成哥德尔机容许的可能环境的一个表示。\(\mu\) 是从 \(M\) 到概率的映射，也在 \(s\) 内编码。\(c\) 不止是编码将来会被执行的指令的 (部分展开的) 表示，而且编码了集合 \(K\)，\(K\) 是状态-延续对的集合，代表执行 \(c\) 的第一个指令后所有可能的下一步的状态和延续； \(c\) 还编码了从 \(K\) 到概率的映射 \(\kappa\)。所以 \(\mu\) 和 \(\kappa\) 分别是样本空间 \(M\) 和 \(K\) 上的 (离散) 概率分布。\(r_{\bar{s}}(s, env)\) 决定在环境 \(env\) 里状态 \(s\) 是否是有利的。比如，在求解器 (是 \(s\) 的一部分) 是个 RL 程序的情况，\(r_{\bar{s}}(s, env)\) 仅当在 \(s\) 代表刚刚执行一个接收输入的指令后的状态时才不是 0。最后，\(\mathbb{E}_{\kappa_c,K_c}\left[u_{\bar{s}} | env\right]\) 对 \(u\) 递归，相应的态和延续来自执行延续 \(c\) 里的下一条指令。
</p>

<p>
关键的一点是要注意到 \(u\) 和 \(r\) 是来自评估态 \(\bar{s}\)，而不是被评估态 \(s\)。后一种做法会破坏哥德尔机的全局最优性，因为那样的话它将能以任何方式 (包括有害的方式) 重写其效用函数。因此，起初的、未被改动的效用函数 \(\bar{s}\) 应该被先用来证明重写是有用的。与此对照，\(\mu\) 和 \(M\) 是来自 \(s\)，因为对于任何有点意思的哥德尔机，\(c\) 会同时限制影响外部环境的指令 (比如输出给行动器)，以及据此更新外部环境 (在 \(s\) 内编码) 的内部模型的指令。类似地，\(\kappa\) 和 \(K\) 取自 \(c\)，因为每次执行指令后延续必定变化，导致 \(\kappa\) 和 \(K\) 的更新。
</p>

<p>
还要注意到 \(u\) 这个函数是递归的。方程 \eqref{eq_usbar} 中，一个哥德尔机的生命在延续样本 \(K_c\) 为空时中止。在那个情况，\(\mathbb{E}_{\kappa_c,K_c}\left[u_{\bar{s}} | env\right]\) 是零而对 \(u\) 的递归停止。在最常见的情形，指令是决定论性的，比如 \(K_c=\left\{(s',c')\right\}\)。这时 \eqref{eq_usbar} 简化为 \(u_{\bar{s}}(s,c) = \mathbb{E}_{\mu_s,M_s}\left[r_{\bar{s}}(s,\cdot)\right] + u_{\bar{s}}(s',c')\)。于是对于决定论性的状态转换，累积未来效用的期望值约简到对后续状态预期奖励的求和。但是比如在 RL 的设定下，即便那些期望收益一般也都是零，因为多数指令不涉及从环境中接收信息 (而这在 RL 中一般是奖励的来源)。
</p>

<p>
我们现在可以介绍目标定理 (target theorem) 了；它是基于效用函数 \(u\) 的。让 \(s\) 表示在某个时间 \(t\) 之前的一个预期未来状态。进一步，让 \(c^\ast = \left\{wait\_until(t); switchprog()\right\}\) 表示一直等待直到时间 \(t\) 的延续 (比如，通过不断调用一个基本时钟函数直到返回的时间大于或等于 \(t\))，之后执行 \(switchprog\)，而这个程序会检查并修改 \(s\) 的任何部分。现在 \(u_{\bar{s}}(s,c^\ast)\) 告诉我们在时刻 \(t\) 在 \(s\) 态上执行 \(switchprog\) 的期望累积未来效用是什么。如果这个效用大于不转换 (switch) 的预期累积未来效用，则这个哥德尔机必须在 \(t\) 时刻执行转换。这样，搜索器的目的是要找到一个状态 \(s\)，一个时刻 \(t\)，以及一个不接收自变量 (nullary) 的子程序 \(switchprog\)，使得 \(\mathfrak{tt}_{\bar{s}}(s, t, switchprog)\) 成立，这里：
\begin{equation}
    \mathfrak{tt}_\bar{s}(s, t, switchprog) = \left[ u_\bar{s}(s, \left\{wait\_until_s(t); switchprog()\right\}) {>} u_\bar{s}(s, \left\{scheduler_s()\right\})\right]
\end{equation}
这里 \(scheduler\) 是让哥德尔机的求解器和搜索器交织起来的子程序。因此 \(\left\{scheduler_s()\right\}\) 表示从 \(s\) 态出发“照常继续”的延续 (包括搜索新的 \(switchprog\))。注意，由于 \(switchprog\) 可能会重写调度器，它必须在其最后一条指令启动一个新的调度器 (如果有必要)，或者简单地启动旧调度器 (如果没有被改变的话)。
</p>

<p>
有两种方法可被用来从这个目标定理找到可被证明有用的自我修改：(1) 生成候选 \(switchprog\) (比如，一个执行优化技术 (也被前沿的编译器使用) 的程序)，生成一个转换时间 \(t\)——\(t\) 不早于评估运行 \(switchprog\) 的效用所需要的时间，以及为当前状态 \(s\) 生成一个拷贝 \(\bar{s}\)；然后在 \(s\) 上运行由 \(\mathfrak{tt}\) 指定的两个延续 (这是安全的，因为 \(s\) 相当于一个沙盒)，直到可以确认那个不等式是否成立，或者直到时间超过 \(t\)；如果不等式不成立或者超时，那么生成一个新的 \(switchprog\) 然后重来；否则，把当前状态与 \(s\) 交换，等待直到时间 \(t\) 然后执行 \(switchprog\)。(2) 从一个公理系统出发生成定理 (或者产生可以计算定理的程序)，测试它们与 \(\mathfrak{tt}\) 的等价性。第一种方法可被视为自顶向下证明 \(\mathfrak{tt}\) 的方法，而第二种是从下往上的。混合的方法也是可能的，所以这种对目标定理的描述允许一系列可能的哥德尔机实现。
</p>

<p>
为了让哥德尔机就算在第一次自我改写之前就是渐进最优的，可以把它初始化为 Hutter 的 Hsearch 算法，一种对所有良好定义问题的非自指但渐进最快的算法，其中使用了硬植入的蛮力证明搜索器并忽略了证明搜索的成本。给定这样的问题，哥德尔机可能会决定把 Hsearch 替换为更快的方法从而减小恒定开销，但就算不能减小，其性能也不会比渐进最优差。
</p>

<p>
解释了一个需要自省的系统的例子，下面我们继续解释获得自省的技术方面。
</p>

<h2>自省系统的理论基础</h2>

<blockquote>
八十年代中期有股自省解释器的风潮，带来了一个著名的词语，“自省塔”。想象一个迷雾缭绕的沼泽，一个矗立着的顶端隐没于灰暗天空的高塔——纯粹的 Rackham 风格！(...) 说起来，谁没有梦想过发明 (或至少可获得) 一种语言，在里面任何东西都可以被重定义，我们的想象可以信马由缰，可以获得完全的编程自由任意玩耍而没有束缚和阻碍？
<p align="right">来自 Queinnec, <cite>LISP in small pieces</cite></p>
</blockquote>

<p>
Queinnec 这样诗意描绘的自省塔是对进行自省 (这里理解为检查和修改自身的正在运行的代码) 时发生的事情的图像化。运行在第 \(n\) 层的程序是运行在第 \(n-1\) 层的求值器的效果。当一个第 \(n\) 层的程序执行一次自省指令时，这意味着它可以访问运行在 \(n-1\) 层的程序的状态。但第 \(n\) 层的程序也能启动求值器，这导致一个程序在 \(n+1\) 层运行。如果一个取值器计算一个正在计算一个...取值器的值，我们得到“矗立着的顶端隐没于灰暗天空的高塔”的图景。如果一个程序正在自省一个正在自省一个正在自省一个...自省程序，我们得到“塔底迷雾缭绕”的图景。如果我们踏上塔的底层会发生什么？在自省塔的原始版本中，没有底层，因为往两个方向都是无限的。当然，现实中这样的无限性必须被放宽，但要点是，问题具体何时何地以及如何浮现，是个极有意思的话题，而这是本节要讲的。
</p>

<p>
</p>

<p>
</p>

<h3>基础 \(\lambda\)-运算</h3>
<p>
</p>

<h3>常数，条件，副作用，引用</h3>
<p>
</p>

<h2>嵌套的元循环评估器</h2>
<p>
</p>

<h2>函数式自省系统</h2>
<p>
</p>

<h2>讨论</h2>
<p>
</p>

<h2>附录：本文用到的符号</h2>
<p>
</p>
