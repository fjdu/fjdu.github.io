---
layout: post
title:  "区块链的科学 - 第二章 容错性与 Paxos"
date:   2016-07-22 Fri 02:51:10
categories: algorithm
---

作者：[Roger Wattenhofer](http://www.dcg.ethz.ch/members/wroger.html)

如何创造一个容错分布式系统？本章我们从简单问题开始，一步一步地改进，直到获得一个即便在不利环境下也能工作的系统，Paxos。

# 2.1 客户/服务器

<p>
<b>定义 2.1</b> (节点).  我们把系统中的单个参与者称为<b>节点</b>。在计算机网络里计算机就是节点，在经典的客户/服务器模型里服务器和客户都是节点，等等。如果没有特别说明，系统里的节点数都是 \(n\)。
</p>

<p>
<b>模型 2.2</b> (消息传递). 在<b>消息传递模型</b>里我们研究由节点组成的分布式系统。每个节点可以执行本地运算，并且能向每个别的节点发送消息。
</p>

**述评：**

- 我们从两个节点组成的系统开始。我们有一个客户节点，它要对远程的服务器节点上的数据进行操作 (存储，更新，等等)。

<p>
<hr>
<b>算法 2.3</b>  朴素客户/服务器算法</b><br/>
1: 客户每次向服务器发送一个命令
<hr>
</p>

<p>
<b>模型 2.4</b> (消息丢失). 带有<b>消息丢失</b>的消息传递模型里，不能保证<b>任何</b>特定消息会安全到达接收者。
</p>

**述评：**

- 一个相关的问题是消息损坏，即消息被收到但内容受损。在实践中，与消息丢失不同，消息损坏可以被很好处置，比如向消息通过添加校验码之类的额外信息。
- 算法 2.3 在消息丢失的情况下不能正确工作，所以我们需要改进一点点。

<p>
<hr>
<b>算法 2.5</b> 带有确认的客户/服务器算法<br/>
1. 客户每次向服务器发送一条指令<br/>
2. 服务器确认每条指令<br/>
3. 如果客户没有在一个合理的时间内收到确认，则重新发送指令
<hr>
</p>

**述评：**

<ul>
<li> “每次发送一条指令”意味着当客户发出指令 \(c\) 时，在收到针对 \(c\) 的确认之前不会发出下一条指令。</li>
<li> 不止是客户发出的消息可能丢失，服务器发回的确认也可能丢失，因此客户有可能会重新发送已经被接收并执行的命令。为了避免相同的命令被多次执行，可以向每条消息添加一个序号，这样接收者就能识别重复消息了。</li>
<li> 这个简单的算法是许多可靠协议的基础，比如 TCP。</li>
<li> 可以很容易地扩展这个算法以适用于多个服务器的情况：客户把每个命令发送到每个服务器，然后，当客户收到每个服务器发来的确认时，就认为命令成功执行了。</li>
<li> 多个客户的情况呢？</li>
</ul>

<p>
<b>模型 2.6</b> (可变消息延迟). 实践中，消息的传输可能需要不同的时间，即便是在同样两个节点之间传输。
</p>

**述评：**

- 本章中，我们假定可变消息延迟模型。

<b>定理 2.7</b>.  如果算法 2.5 被用于多个客户和多个服务器，那么不同服务器看到的命令顺序可能不同，导致不一致的状态。

<p>
<em>证明</em>.  假定两个客户 \(u_1\) 和 \(u_2\)，两个服务器 \(s_1\) 和 \(s_2\)。两个客户都发出命令改变服务器上的一个变量 \(x\) 的值，初值为 \(x=0\)。客户 \(u_1\) 发出的指令是 \(x = x + 1\)，客户 \(u_2\) 发出的指令是 \(x = 2 \cdot x\)。
</p><p>
如果 \(s_1\) 先收到来自 \(u_1\) 的消息，而 \(s_2\) 先收到来自 \(u_2\) 的消息 (比如有可能 \(u_1\) 与 \(s_1\) 地理上距离近，而 \(u_2\) 与 \(s_2\) 距离近)，那么，\(s_1\) 的计算结果是 \(x = (0+1)\cdot 2 = 2\)，而 \(s_2\) 的计算结果是 \(x = (0\cdot 2) + 1 = 1\)。
<div align="right">\(\square\)</div>
</p>

<p>
<b>定义 2.8</b> (状态复制).  如果所有节点按相同顺序执行一个指令序列 \(c_1,\ c_2,\ \ldots\) (序列可能无限长)，则我们说这些节点达成了<b>状态复制</b>。
</p>


**述评：**

- 状态复制是分布式系统的基本性质。
- 对于金融技术行业的人来说，状态复制经常就是区块链的同义词。第七章我们将会讨论的比特币区块链其实就是一种实现状态复制的方法。但是，正如我们要在其它章节看到的，还有许多值得了解的其它概念可供选择，性质各不相同。
- 对于单个服务器而言，状态复制是平凡的任务，因此我们可以指定一个单独的服务器作为序列器 (serializer)。通过让序列器来分发指令，我们自动地对请求排好序并且达成了状态复制！

<p>
<hr>
<b>算法 2.9</b> 用序列器实现状态复制<br/>
1. 客户把每次发送一个指令到序列器<br>
2. 序列器每次转发一个指令到所有其它服务器<br>
3. 序列器收到所有的确认后告知客户
<hr>
</p>

**述评：**

- 这个想法有时被称为主-从 (master-slave) 复制。
- 节点故障？序列器是个单故障点 (single point of failure)！一旦它出故障，整个系统就都不能运作了。
- 我们能否有一个更加分布式的解决状态复制的方法？与其直接确立指令的一致顺序，我们可以采用一个不同的方法：我们可以保证每个时刻至多只有一个客户在发送指令；也就是说，我们使用互斥 (mutual exclusion)，各自加锁。

<p>
<hr>
<b>算法 2.10</b> 二相协议<br/>
<em>第一相</em><br>
1. 客户向所有服务器请求锁<br>
<em>第二相</em><br>
2. 如果客户收到每个服务器的锁，那么<br>
3.      &emsp;&emsp;客户把指令发给每个服务器，并归还锁<br>
4. 否则<br>
5.      &emsp;&emsp;客户归还收到的那些锁<br>
6.      &emsp;&emsp;客户等待一会儿，然后回到第一相再次执行
<hr>
</p>

**述评：**

- 这个想法在许多场景中出现，叫法各不同，细节稍有变化，比如二相锁 (two-phase locking; 2PL)。
- 另一个例子是二相承诺协议 (two-phase commit; 2PC)，经常在数据库环境中出现。第一相被称为交易准备，而在第二相，交易要么被承诺，要么被中止。这个 2PC 过程不是由客户发起，而是由一个指定的被称为协调器的服务器节点发起。
- 一个常见的说法是，如果节点可以在崩溃后恢复，那么 2PL 和 2PC 比简单的序列器提供了更好的一致性保证。特别地，对于崩溃前启动的交易而言，活着的节点或许可以与崩溃的节点保持一致。这个好处在多一个相的另一个协议 (3PC) 那里得到了进一步改善。
- 2PC 和 3PC 的问题是，在意外情况发生时，它们不是良好定义的。
- 算法 2.10 真的很好地处理了节点崩溃问题吗？并没有！事实上，它比算法 2.9 里那个简单的序列器更坏：相比于要求必须能访问某一个节点，算法 2.10 要求所有的服务器都能响应。
- 如果我们只从服务器的一部分得到锁，算法 2.10 还能工作吗？是否从服务器的多数得到锁就够了？
- 如果两个客户同时试图获得大多数锁，会怎么样？客户是否必须废弃已经获得的锁，以免出现死锁？怎么进行？如果它们在释放锁之前崩溃了又如何？我们是否需要稍微不同的概念？

# 2.2 Paxos

<p>
<b>定义 2.11</b> (凭证; ticket).  <b>凭证</b>是锁的弱形式，具有如下性质：
<ul>
  <li><b>可重发：</b> 一个服务器可以重新发布一个凭证，即便之前发布的没有被归还。</li>
  <li><b>票据过期：</b> 如果客户使用之前获得的凭证 \(t\) 往服务器发送一条消息，仅当 \(t\) 是最新发布的凭证时服务器才接受 \(t\)。</li>
</ul>
</p>

**述评：**

- 崩溃不导致问题：如果一个客户在持有凭证期间崩溃了，其余的客户不受到影响，因为服务器可以简单地发布新的凭证。
- 凭证可以通过一个计数器实现：每收到一次凭证请求，计数器加一。当一个客户试图使用一个凭证时，服务器可以决定这个凭证是否过期了。
- 我们能对凭证做什么？我们能否简单地把算法 2.10 里的锁替换成凭证？我们需要添加至少一个额外的相，因为只有客户知道在第二相中是否多数凭证是有效的。

<p>
<hr>
<b>算法 2.12</b> 朴素凭证协议<br/>
<em>第一相</em><br>
1. 客户向所有服务器请求凭证<br>
<em>第二相</em><br>
2. 如果客户收到多数服务器的回复，那么<br>
3.      &emsp;&emsp;客户把指令和凭证一起发给每个服务器<br>
4.      &emsp;&emsp;服务器仅当凭证依然有效时保存指令，并且回复服务器<br>
5. 否则<br>
6.      &emsp;&emsp;客户等待，然后回到第一相再次执行<br>
<em>第三相</em><br>
7. 如果客户从多数服务器收到正面回答，那么<br>
8.      &emsp;&emsp;客户告诉服务器执行保存的命令<br>
9. 否则<br>
10.    &emsp;&emsp;客户等待，然后回到第一相再次执行<br>
<hr>
</p>

**述评：**

<ul>
<li>这个算法有些问题：假设客户 \(u_1\) 第一个将其指令 \(c_1\) 保存在多数服务器上。假定 \(u_1\) 刚好在通知服务器之前 (第三相之前) 变得很慢，而另一个客户 \(u_2\) 将某些服务器上存储的指令更新为 \(c_2\)。之后，\(u_1\) 告诉让服务器执行存储的指令。现在，有些服务器执行 \(c_1\)，有些执行 \(c_2\)！</li>
</ul>

<p>
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<p>
</p>

<p>
</p>
