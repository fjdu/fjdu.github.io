---
layout: post
title:  "区块链的科学 - 第二章 容错性与 Paxos"
date:   2016-07-22 Fri 02:51:10
categories: algorithm
---

作者：[Roger Wattenhofer](http://www.dcg.ethz.ch/members/wroger.html)

如何创造一个容错分布式系统？本章我们从简单问题开始，一步一步地改进，直到获得一个即便在不利环境下也能工作的系统，Paxos。

# 2.1 客户/服务器

<p>
<b>定义 2.1</b> (节点).  我们把系统中的单个参与者称为<b>节点</b>。在计算机网络里计算机就是节点，在经典的客户/服务器模型里服务器和客户都是节点，等等。如果没有特别说明，系统里的节点数都是 \(n\)。
</p>

<p>
<b>模型 2.2</b> (消息传递). 在<b>消息传递模型</b>里我们研究由节点组成的分布式系统。每个节点可以执行本地运算，并且能向每个别的节点发送消息。
</p>

**述评：**

- 我们从两个节点组成的系统开始。我们有一个客户节点，它要对远程的服务器节点上的数据进行操作 (存储，更新，等等)。

<p>
<hr>
<b>算法 2.3</b>  朴素客户/服务器算法</b><br/>
1: 客户每次向服务器发送一个命令
<hr>
</p>

<p>
<b>模型 2.4</b> (消息丢失). 带有消息丢失的消息传递模型里，不能保证任何特定消息会安全到达接收者。
</p>

**述评：**

- 一个相关的问题是消息损坏，即消息被收到但内容受损。在实践中，与消息丢失不同，消息损坏可以被很好处置，比如向消息通过添加校验码之类的额外信息。
- 算法 2.3 在消息丢失的情况下不能正确工作，所以我们需要改进一点点。

<p>
<hr>
<b>算法 2.5</b> 带有确认的客户/服务器算法<br/>
1. 客户每次向服务器发送一条指令<br/>
2. 服务器确认每条指令<br/>
3. 如果客户没有在一个合理的时间内收到确认，则重新发送指令
<hr>
</p>

**述评：**

<ul>
<li> “每次发送一条指令”意味着当客户发出指令 \(c\) 时，在收到针对 c 的确认之前不会发出下一条指令。</li>
<li> 不止是客户发出的消息可能丢失，服务器发回的确认也可能丢失，因此客户有可能会重新发送已经被接收并执行的命令。为了避免相同的命令被多次执行，可以向每条消息添加一个序号，这样接收者就能识别重复消息了。</li>
<li> 这个简单的算法是许多可靠协议的基础，比如 TCP。</li>
<li> 可以很容易地扩展这个算法以适用于多个服务器的情况：客户把每个命令发送到每个服务器，然后，当客户收到每个服务器发来的确认时，就认为命令成功执行了。</li>
<li> 多个客户的情况呢？</li>
</ul>

<p>
<b>模型 2.6</b> (可变消息延迟). 实践中，消息的传输可能需要不同的时间，即便是在同样两个节点之间传输。
</p>

**述评：**

- 本章中，我们假定可变消息延迟模型。

<b>定理 2.7</b>.  如果算法 2.5 被用于多个客户和多个服务器，那么不同服务器看到的命令顺序可能不同，导致不一致的状态。

<p>
<em>证明</em>.  假定两个客户 \(u_1\) 和 \(u_2\)，两个服务器 \(s_1\) 和 \(s_2\)。两个客户都发出命令改变服务器上的一个变量 \(x\) 的值，初值为 \(x=0\)。客户 \(u_1\) 发出的指令是 \(x = x + 1\)，客户 \(u_2\) 发出的指令是 \(x = 2 \cdot x\)。
</p><p>
如果 \(s_1\) 先收到来自 \(u_1\) 的消息，而 \(s_2\) 先收到来自 \(u_2\) 的消息，那么，\(s_1\) 的计算结果是 \(x = (0+1)\cdot 2 = 2\)，而 \(s_2\) 的计算结果是 \(x = (0\cdot 2) + 1 = 1\)。
</p>

<p>
</p>

<p>
</p>

<p>
</p>
